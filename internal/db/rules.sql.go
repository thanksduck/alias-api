// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: rules.sql

package q

import (
	"context"
)

const createNewRule = `-- name: CreateNewRule :exec
INSERT INTO rules (user_id, username, alias_email, destination_email, comment, name)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateNewRuleParams struct {
	UserID           int64  `json:"userId"`
	Username         string `json:"username"`
	AliasEmail       string `json:"aliasEmail"`
	DestinationEmail string `json:"destinationEmail"`
	Comment          string `json:"comment"`
	Name             string `json:"name"`
}

func (q *Queries) CreateNewRule(ctx context.Context, arg *CreateNewRuleParams) error {
	_, err := q.db.Exec(ctx, createNewRule,
		arg.UserID,
		arg.Username,
		arg.AliasEmail,
		arg.DestinationEmail,
		arg.Comment,
		arg.Name,
	)
	return err
}

const decrementUserAliasCount = `-- name: DecrementUserAliasCount :exec
UPDATE users
SET alias_count = alias_count - 1
WHERE id = $1
`

func (q *Queries) DecrementUserAliasCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, decrementUserAliasCount, id)
	return err
}

const deleteRuleByID = `-- name: DeleteRuleByID :exec
DELETE FROM rules
WHERE id = $1
`

func (q *Queries) DeleteRuleByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRuleByID, id)
	return err
}

const findActiveRulesByDestinationEmail = `-- name: FindActiveRulesByDestinationEmail :many
SELECT id, user_id, username, alias_email, destination_email, is_active, comment, name
FROM rules
WHERE destination_email = $1 AND is_active = true
`

type FindActiveRulesByDestinationEmailRow struct {
	ID               int64  `json:"id"`
	UserID           int64  `json:"userId"`
	Username         string `json:"username"`
	AliasEmail       string `json:"aliasEmail"`
	DestinationEmail string `json:"destinationEmail"`
	IsActive         bool   `json:"isActive"`
	Comment          string `json:"comment"`
	Name             string `json:"name"`
}

func (q *Queries) FindActiveRulesByDestinationEmail(ctx context.Context, destinationEmail string) ([]*FindActiveRulesByDestinationEmailRow, error) {
	rows, err := q.db.Query(ctx, findActiveRulesByDestinationEmail, destinationEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindActiveRulesByDestinationEmailRow
	for rows.Next() {
		var i FindActiveRulesByDestinationEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.AliasEmail,
			&i.DestinationEmail,
			&i.IsActive,
			&i.Comment,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRuleByAliasEmail = `-- name: FindRuleByAliasEmail :one
SELECT id, user_id, username, alias_email, destination_email, is_active, comment
FROM rules
WHERE alias_email = $1
`

type FindRuleByAliasEmailRow struct {
	ID               int64  `json:"id"`
	UserID           int64  `json:"userId"`
	Username         string `json:"username"`
	AliasEmail       string `json:"aliasEmail"`
	DestinationEmail string `json:"destinationEmail"`
	IsActive         bool   `json:"isActive"`
	Comment          string `json:"comment"`
}

func (q *Queries) FindRuleByAliasEmail(ctx context.Context, aliasEmail string) (*FindRuleByAliasEmailRow, error) {
	row := q.db.QueryRow(ctx, findRuleByAliasEmail, aliasEmail)
	var i FindRuleByAliasEmailRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.AliasEmail,
		&i.DestinationEmail,
		&i.IsActive,
		&i.Comment,
	)
	return &i, err
}

const findRuleByID = `-- name: FindRuleByID :one

SELECT id as rule_id, username, alias_email, destination_email, is_active, comment, name
FROM rules
WHERE id = $1
`

type FindRuleByIDRow struct {
	RuleID           int64  `json:"ruleId"`
	Username         string `json:"username"`
	AliasEmail       string `json:"aliasEmail"`
	DestinationEmail string `json:"destinationEmail"`
	IsActive         bool   `json:"isActive"`
	Comment          string `json:"comment"`
	Name             string `json:"name"`
}

// queries/rules.sql
func (q *Queries) FindRuleByID(ctx context.Context, id int64) (*FindRuleByIDRow, error) {
	row := q.db.QueryRow(ctx, findRuleByID, id)
	var i FindRuleByIDRow
	err := row.Scan(
		&i.RuleID,
		&i.Username,
		&i.AliasEmail,
		&i.DestinationEmail,
		&i.IsActive,
		&i.Comment,
		&i.Name,
	)
	return &i, err
}

const findRulesByDestinationEmail = `-- name: FindRulesByDestinationEmail :many
SELECT id, user_id, username, alias_email, destination_email, is_active, comment, name
FROM rules
WHERE destination_email = $1
`

type FindRulesByDestinationEmailRow struct {
	ID               int64  `json:"id"`
	UserID           int64  `json:"userId"`
	Username         string `json:"username"`
	AliasEmail       string `json:"aliasEmail"`
	DestinationEmail string `json:"destinationEmail"`
	IsActive         bool   `json:"isActive"`
	Comment          string `json:"comment"`
	Name             string `json:"name"`
}

func (q *Queries) FindRulesByDestinationEmail(ctx context.Context, destinationEmail string) ([]*FindRulesByDestinationEmailRow, error) {
	rows, err := q.db.Query(ctx, findRulesByDestinationEmail, destinationEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindRulesByDestinationEmailRow
	for rows.Next() {
		var i FindRulesByDestinationEmailRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.AliasEmail,
			&i.DestinationEmail,
			&i.IsActive,
			&i.Comment,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRulesByUserID = `-- name: FindRulesByUserID :many
SELECT id as rule_id, username, alias_email, destination_email, is_active, comment, name
FROM rules
WHERE user_id = $1
`

type FindRulesByUserIDRow struct {
	RuleID           int64  `json:"ruleId"`
	Username         string `json:"username"`
	AliasEmail       string `json:"aliasEmail"`
	DestinationEmail string `json:"destinationEmail"`
	IsActive         bool   `json:"isActive"`
	Comment          string `json:"comment"`
	Name             string `json:"name"`
}

func (q *Queries) FindRulesByUserID(ctx context.Context, userID int64) ([]*FindRulesByUserIDRow, error) {
	rows, err := q.db.Query(ctx, findRulesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindRulesByUserIDRow
	for rows.Next() {
		var i FindRulesByUserIDRow
		if err := rows.Scan(
			&i.RuleID,
			&i.Username,
			&i.AliasEmail,
			&i.DestinationEmail,
			&i.IsActive,
			&i.Comment,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementUserAliasCount = `-- name: IncrementUserAliasCount :exec
UPDATE users
SET alias_count = alias_count + 1
WHERE id = $1
`

func (q *Queries) IncrementUserAliasCount(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, incrementUserAliasCount, id)
	return err
}

const makeAllRuleInactiveByDestinationEmail = `-- name: MakeAllRuleInactiveByDestinationEmail :exec
UPDATE rules
SET is_active = false
WHERE destination_email = $1
`

func (q *Queries) MakeAllRuleInactiveByDestinationEmail(ctx context.Context, destinationEmail string) error {
	_, err := q.db.Exec(ctx, makeAllRuleInactiveByDestinationEmail, destinationEmail)
	return err
}

const toggleRuleByID = `-- name: ToggleRuleByID :exec
UPDATE rules
SET is_active = NOT is_active
WHERE id = $1
`

func (q *Queries) ToggleRuleByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, toggleRuleByID, id)
	return err
}

const updateRuleByID = `-- name: UpdateRuleByID :exec
UPDATE rules
SET alias_email = $1,
    destination_email = $2,
    comment = $3,
    name = $4
WHERE id = $5
`

type UpdateRuleByIDParams struct {
	AliasEmail       string `json:"aliasEmail"`
	DestinationEmail string `json:"destinationEmail"`
	Comment          string `json:"comment"`
	Name             string `json:"name"`
	ID               int64  `json:"id"`
}

func (q *Queries) UpdateRuleByID(ctx context.Context, arg *UpdateRuleByIDParams) error {
	_, err := q.db.Exec(ctx, updateRuleByID,
		arg.AliasEmail,
		arg.DestinationEmail,
		arg.Comment,
		arg.Name,
		arg.ID,
	)
	return err
}
